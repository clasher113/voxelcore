#include "frontend/workshop/WorkshopScreen.hpp"

#include "items/ItemDef.hpp"
#include "content/Content.hpp"
#include "graphics/ui/elements/Panel.hpp"
#include "graphics/ui/elements/Label.hpp"
#include "graphics/ui/elements/Button.hpp"
#include "graphics/ui/elements/TextBox.hpp"
#include "frontend/workshop/gui_elements/BasicElements.hpp"
#include "frontend/workshop/gui_elements/IconButton.hpp"
#include "frontend/workshop/WorkshopSerializer.hpp"
#include "util/stringutil.hpp"
#include "core_defs.hpp"

#include <filesystem>

namespace fs = std::filesystem;

void workshop::WorkShopScreen::createItemEditor(ItemDef& item) {
	createPanel([this, &item]() {
		std::string actualName(item.name.substr(currentPackId.size() + 1));
		fs::path filePath(currentPack.folder / ContentPack::ITEMS_FOLDER / std::string(actualName + ".json"));
		const bool hasFile = fs::is_regular_file(filePath);

		gui::Panel& panel = *new gui::Panel(glm::vec2(settings.itemEditorWidth));
		if (!hasFile) {
			gui::Label& label = *new gui::Label(L"Autogenerated item from existing block\nCreate file to edit item propreties");
			label.setTextWrapping(true);
			label.setMultiline(true);
			label.setSize(panel.getSize());
			panel << label;

			panel << new gui::Button(L"Create file", glm::vec4(10.f), [this, &item, actualName](gui::GUI*) {
				saveItem(item, currentPack.folder);
				createItemEditor(item);
			});
			return std::ref(panel);
		}
		panel << new gui::Label(actualName);

		panel << new gui::Label("Caption");
		createTextBox(panel, item.caption, L"Example item");

		panel << new gui::Label(L"Parent item");
		auto parentIcoName = [](const ItemDef* const parent) {
			return parent ? parent->name : NOT_SET;
		};
		auto parentIcoTexName = [](const ItemDef* const parent) -> std::string {
			if (parent){
				return parent->iconType == ItemIconType::BLOCK ? BLOCKS_PREVIEW_ATLAS + ':' + parent->icon : parent->icon;
			}
			return "blocks:transparent";
		};

		BackupData& backupData = itemsList[actualName];
		const ItemDef* currentParent = content->items.find(backupData.parent);

		gui::IconButton& parentItem = *new gui::IconButton(assets, 35.f, parentIcoName(currentParent), parentIcoTexName(currentParent));
		parentItem.listenAction([=, &item, &panel](gui::GUI*) {
			if (showUnsaved()) return;
			createContentList(ContentType::ITEM, true, 5, panel.calcPos().x + panel.getSize().x, [=, &item](std::string string) {
				const std::string name = item.name;
				if (string == CORE_EMPTY || string == item.name) string.clear();
				saveItem(item, currentPack.folder, currentParent, string);
				removePanels(1);
				initialize();
				createContentList(ContentType::ITEM);
				createItemEditor(*content->items.getDefs().at(name));
			});
		});
		panel << parentItem;

		panel << new gui::Label(L"Stack size:");
		panel << createNumTextBox<uint32_t>(item.stackSize, L"1", 0, 1, 64);
		createEmissionPanel(panel, item.emission);

		panel << new gui::Label(L"Icon");
		gui::Panel& textureIco = *new gui::Panel(glm::vec2(panel.getSize().x, 35.f));
		createTexturesPanel(textureIco, 35.f, item.icon, item.iconType);
		panel << textureIco;

		const wchar_t* const iconTypes[] = { L"none", L"sprite", L"block" };
		gui::Button* button = new gui::Button(L"Icon type: " + std::wstring(iconTypes[static_cast<unsigned int>(item.iconType)]), glm::vec4(10.f), gui::onaction());
		button->listenAction([this, button, iconTypes, &item, &textureIco, &panel](gui::GUI*) {
			const char* const icons[] = { CORE_AIR.c_str(), "blocks:notfound", CORE_AIR.c_str() };
			incrementEnumClass(item.iconType, 1);
			if (item.iconType > ItemIconType::BLOCK) item.iconType = ItemIconType::NONE;
			item.icon = icons[static_cast<size_t>(item.iconType)];
			removePanels(3);
			button->setText(L"Icon type: " + std::wstring(iconTypes[static_cast<unsigned int>(item.iconType)]));
			removeRemovable(textureIco);
			createTexturesPanel(textureIco, 35.f, item.icon, item.iconType);
			textureIco.cropToContent();
			panel.refresh();
		});
		panel << button;

		panel << new gui::Label(L"Placing block");
		gui::Panel& placingBlockPanel = *new gui::Panel(glm::vec2(panel.getSize().x, 35.f));
		createTexturesPanel(placingBlockPanel, 35.f, item.placingBlock, ItemIconType::BLOCK);
		panel << placingBlockPanel;

		panel << new gui::Label("Script file");
		panel << (button = new gui::Button(util::str2wstr_utf8(getScriptName(currentPack, item.scriptName)), glm::vec4(10.f), gui::onaction()));
		button->listenAction([=, &panel, &item](gui::GUI*) {
			createScriptList(5, panel.calcPos().x + panel.getSize().x, [=, &item](const std::string& string) {
				removePanels(5);
				std::string scriptName(getScriptName(currentPack, string));
				item.scriptName = (scriptName == NOT_SET ? (getScriptName(currentPack, actualName) == NOT_SET ? actualName : "") : scriptName);
				button->setText(util::str2wstr_utf8(scriptName));
			});
		});

		panel << new gui::Button(L"Save", glm::vec4(10.f), [=, &item, &backupData](gui::GUI*) {
			const std::string parentName = currentParent ? currentParent->name : "";
			backupData.serialized = stringify(item, currentParent, parentName);
			saveItem(item, currentPack.folder, currentParent, parentName);
		});

		bool isParent = false;
		std::wstring parentOf = L"Action impossible: Parent of ";
		for (const auto& [name, data] : itemsList) {
			if (data.parent == item.name) {
				parentOf.append(util::str2wstr_utf8(name) + L'\n');
				isParent = true;
			}
		}

		if (!item.generated) {
			panel << (button = new gui::Button(L"Rename", glm::vec4(10.f), gui::onaction())); 
			if (isParent) button->setTooltip(parentOf);
			else button->listenAction([=](gui::GUI*) {
				createDefActionPanel(ContentAction::RENAME, ContentType::ITEM, actualName);
			});
		}

		panel << (button = new gui::Button(L"Delete", glm::vec4(10.f), gui::onaction()));
		if (isParent) button->setTooltip(parentOf);
		else button->listenAction([=, &item](gui::GUI*) {
			createDefActionPanel(ContentAction::DELETE, ContentType::ITEM, actualName, !item.generated);
		});

		return std::ref(panel);
	}, 2);
}